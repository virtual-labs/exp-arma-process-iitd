<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <title>Virtual Labs</title>
  </head>
  <body>
    <!-- sidebar and body -->
	    <!-- sidebar and body -->
	<div id = "instructions">
    <h1>Instructions for Spectral Estimation using AR-Modeled Yule-Walker Method</h1>

<ul>
    <li class="step step1"><strong>Step 1:</strong> Click on <em>"Generate Input Signal"</em> to generate the signal.</li>
    <li class="step step2"><strong>Step 2:</strong> Enter the input signal frequency (Hz), sampling frequency (Hz), and the AR model order in the parameters section.</li>
    <li class="step step3"><strong>Step 3:</strong> Select the base signal from the dropdown menu.</li>
    <li class="step step4"><strong>Step 4:</strong> Choose an operation such as addition, multiplication, or convolution from the dropdown menu.</li>
    <li class="step step2"><strong>Step 5:</strong> Add AWGN noise by entering the SNR value (in dB) in the 'AWGN Noise' section.</li>
    <li class="step step1"><strong>Step 6:</strong> Click the <em>"Simulate"</em> button to run the simulation.</li>
    <li class="step step2"><strong>Step 7:</strong> Reset the simulator by clicking the <em>"Reset Simulator"</em> button.</li>
</ul>

	</div>
	<hr/>
	
    <!-----------------------------framework starts-------------------------------->
	    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 2em;
        }

        .containerff {
            display: flex;
            gap: 2em;
            margin-bottom: 2em;
        }

        .box {
            border: 0.2em solid #333;
            padding: 1em;
            text-align: center;
            flex: 1;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            height: 0;
            overflow: hidden;
            transition: opacity 0.3s ease, height 0.3s ease;
        }

        .four-boxes {
            display: flex;
            gap: 2em;
            margin-top: 2em;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .dropdown, .input-box {
            margin-top: 1em;
            text-align: left;
        }

select, input {
    width: 100%;
    padding: 0.5em;
    font-size: 1em;
    border: 2px solid black; /* Adds a solid black border */
    border-radius: 4px; /* Optional: Rounds the corners */
}

  /* Popup effect style */
  .popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(1.1);
  box-shadow: 0 4px 12px rgba(0,0,0,0.5);
  z-index: 999;
  background: white;
}

/* Close button - hidden by default */
.close-btn {
  position: absolute;
  top: 5px;
  right: 8px;
  font-size: 18px;
  font-weight: bold;
  cursor: pointer;
  color: #333;
  display: none; /* Hidden initially */
}
.close-btn:hover {
  color: red;
}

/* Show close button only when popup is active */
.popup .close-btn {
  display: block;
}
#boxes {
    display: none;
}
    </style>
	<br/>
	<br/>
    <div class="containerff">
        <div class="box">
            <!-------------
                onclick = "popUpDiv()"
                --------->
            <button 
			class="button bg-blue-500 text-white rounded-md px-2 py-1"
			id="triggerButton"  onclick = "inputSignal()" aria-expanded="false">Generate Input Signal</button>
            <a href="#realData">
                <button 
                  class="button bg-blue-500 text-white rounded-md px-2 py-1"
                  onclick="showDiv()"
                  aria-expanded="false">
                  Input Real Data
                </button>
              </a>
            <div id="inputSignal1" class="w-[30em] h-[20em]"></div>
        </div>

        <div class="box" id="inputFieldsBox">
        <span class="close-btn" onclick="closePopup()">&times;</span>
		<p>Parameters</p>
		<br>
		<label for = "messageFrequency">Input Signal Frequency (Hz)</label>
            <input id = "messageFrequency" type="text" value="50" min = "1">

            <label for = "samplingFrequency">Sampling Frequency (Hz)</label>
            <input id = "samplingFrequency" type="text" value="1000" min = "1">

			<label for="inputN">AR Model order(s):</label>
    <input type="number" id="inputN" value="10" min = "5" max = "50" />
    <br/><br/>
    <button 
    class="button bg-blue-500 text-white rounded-md px-2 py-1"
    onclick = "simulateff()">Simulate</button>
			<!--
            <input type="text" placeholder="Input 2">
            <input type="text" placeholder="Input 3">
			-->
    <!------------------------------------------>
    <div style="display:none;">
                    <label for = "samplingFrequency">Sampling Frequency (Hz)</label>
                <input id = "samplingFrequency" type="text" value="1000">
                    <label for = "signalLength">Length of the Signal (Samples)</label>
                <input id = "signalLength" type="text" value="10000">
            <label for = "messageFrequency">Input Signal Frequency (Hz)</label>
                <input id = "messageFrequency" type="text" value="10">
                    <label for="windowType">Window Type:</label>
        <select id="windowType">
            <option value="rectangular">Rectangular Window</option>
            <option value="hann">Hann Window</option>
            <option value="hamming" selected>Hamming Window</option>
        </select>
        <label for = "windowSize">Window Size</label>
        <input id = "windowSize" type="text" value="512">
                <label for = "pulseWidthff">Pulse Width (s)</label>
                <input id = "pulseWidthff" type="number" value="0.2" step = "0.1">
            </div>
        <!---------------------------------------->
        </div>

        <div class="box" id = "outputxx">
            <p>Power Spectral Density (PSD) Estimation</p>
						<div id="arCoefficientsBox" style="border: 1px solid black; padding: 10px; margin-bottom: 10px; font-size: 14px; white-space: pre-wrap;"></div>

			<div id="psdPlot2" class="w-[40em] h-[20em]"></div>
        </div>
    </div>

    <div class="four-boxes hidden" id="additionalBoxes">
        <div class="box" id="dropdownBox1">
            <p>Base Signal</p>
            <div class="dropdown">
    <select id="inputSelector" onchange="handleInputChange()">
        <option value="" disabled selected>Select an input</option>
        <option value="sine" selected>Sine Wave</option>
        <option value="cosine">Cosine Wave</option>
		<!--
		<option value="rectangular">Rectangular Wave</option>
		-->
    </select>
            </div>
        </div>

        <div class="box" id="dropdownBox2">
            <p>Operations</p>
            <div class="dropdown">
    <select id="masterInputSelector" onchange="handleInputChange()">
        <option value="" disabled selected>Select an operation</option>
		<option value="fourierDifferentiation"  selected>None</option>
        <option value="addition">Addition</option>
        <option value="subtraction">Subtraction</option>
		<option value="multiplication">Multiplication</option>
        <option value="convolution">Convolution</option>
    </select>
	<br/>
	<br/>
			<div>
	    <!-- Dropdown for user input selection -->
    <label for="inputSelector2">Add another Signal:</label>
    <select id="inputSelector2" onchange="handleInputChange()">
	    <option value="" disabled selected>Select an input</option>
        <option value="sine" selected>Sine Wave</option>
        <option value="cosine">Cosine Wave</option>
		<!--
		<option value="rectangular">Rectangular Wave</option>
		-->
    </select>
			</div>
			
			<br/>
			
			<div>
        <label for="carrierFrequency">Input Frequency (Hz):</label>
<input class="input-field border border-black px-2 py-1 rounded-sm" type="number" id="carrierFrequency" value="100" min = "1">
                </div>
				<div id="inputSignal2" class="w-[30em] h-[20em]"></div>			
            </div>
        </div>

        <div class="box" id="inputBox1">
            <p>AWGN Noise</p>
            <div class="input-box">
			    <label for="snrInput">SNR (in dB):</label>
                <input id="snrInput" type="text" value="10">
            </div>
		    <div id="plot12" class="w-[30em] h-[20em]"></div>
        </div>

        <div class="box" id="inputBox2">
		<!--
            <p>Input Box 2</p>
            <div class="input-box">
                <input type="text" placeholder="Input 2">
		-->

		<br><br>
		<button 
		class="button bg-green-500 text-white rounded-md px-2 py-1"
		onclick = "window.location.reload(true);">Reset Simulator</button>
            </div>
        </div>
    </div>

    <script>
        const triggerButton = document.getElementById('triggerButton');
        const additionalBoxes = document.getElementById('additionalBoxes');

        triggerButton.addEventListener('click', () => {
            const isHidden = additionalBoxes.classList.toggle('hidden');
            triggerButton.setAttribute('aria-expanded', !isHidden);
        });
    </script>
	
    <!-------------------------------framework ends--------------------------------->	
				<button
                  onclick="inputSignal1()"
                >
                </button>
			    <button
				  id = "hideButton1"
                  onclick="generateInputSignal2()"
                >
                </button>
				<button
				  id = "hideButton"
                  onclick="simulation()"
                >
                </button>
								<button
                  onclick="generateNoisySignal()"
                >
                </button>
				
			    <button
                  onclick="generatePSD2()"
                >
                </button>

	            <div id = "scrolltomessage" class="flex items-center gap-2 justify-center max-lg:flex-col">
              <div id="plot11"></div>

<div id = "boxes">	
              <h2 id="realData" class="text-2xl font-bold text-gray-800 mb-4"></h2>
              <div class="containerff">
                  <div class="box">  
                      <div class="w-[30em] h-[20em]">
                          <h2>Upload CSV and See Output</h2>
                          <input type="file" id="csvInput" accept=".csv">
                          <br/><br/><br/>
                          <div class="flex items-center justify-center gap-1 mt-2">
                              <label for="samplingFrequencyxx">Sampling Frequency (Hz):</label>
                      <input class="input-field border border-black px-2 py-1 rounded-sm" type="text" id="samplingFrequencyxx" value="1000" min="1">
                      <label for="inputNxx">AR Model order(s):</label>
                      <input type="number" id="inputNxx" value="10" min = "5" max = "50" />
                                      </div>
                      </div>
                  </div>   
                  <div class="box">
                      <p>Input Signal</p>
                      <div id="signal" class="w-[30em] h-[20em]"></div>
                  </div>
              
                      <div class="box">
                        <div id="arCoefficientsBox1" style="border: 1px solid black; padding: 10px; margin-bottom: 10px; font-size: 14px; white-space: pre-wrap;"></div>

                      <p>Output</p>
                      <div id="output" class="w-[30em] h-[20em]"></div>
                  </div>
              </div>
</div>             	
<script>
        function checkFrequencies2() {
        // Get the selected operation from the dropdown
        const selectedOperation = document.getElementById('masterInputSelector').value;
        const messageFreq = parseFloat(document.getElementById('messageFrequency').value);

        // Define operations for the first condition
        const firstConditionOps = ['none', 'fourierDifferentiation', 'fourierIntegration'];

        if (firstConditionOps.includes(selectedOperation)) {
            // Condition 1: For 'none', 'fourierDifferentiation', 'fourierIntegration'
            // The sampling frequency must be at least twice the message frequency.
            const samplingFreq = parseFloat(document.getElementById('samplingFrequency').value); // Example: Set sampling frequency to 10x the message frequency

            if (samplingFreq < 2 * messageFreq) {
                // If the condition is not met, show an alert.
                alert("Sampling frequency must be higher than twice the input signal frequency.");
                
                // After the user dismisses the alert, reload the page.
                setTimeout(() => {
                    location.reload(); // Using location.reload() is a standard way to refresh.
                }, 0);
            }

        } else {
            // Condition 2: For all other operations ('addition', 'subtraction', etc.)
            const carrierFreq = parseFloat(document.getElementById('carrierFrequency').value);

            // Set sampling frequency to 10 times the higher of the two input frequencies
            const samplingFreq = parseFloat(document.getElementById('samplingFrequency').value);
            // Check if the sampling frequency is sufficient for both input frequencies
            if (samplingFreq < 2 * messageFreq || samplingFreq < 2 * carrierFreq) {
                // If the condition is not met, show an alert.
                alert("Sampling frequency must be higher than twice the frequency of both input signal 1 and input signal 2.");
                
                // After the user dismisses the alert, reload the page.
                setTimeout(() => {
                    window.location.reload(true); 
                }, 0);
            }
        }
    }

    // Select all button elements on the page
    const buttons1 = document.querySelectorAll('button');

    // Attach the click event listener to each button
    buttons1.forEach(button => {
        button.addEventListener('click', checkFrequencies2);
    });
/*
    // Function to check if the sampling frequency is higher than the input frequencies
    function checkFrequencies2() {
        const messageFreq = parseFloat(document.getElementById('messageFrequency').value);
        const carrierFreq = parseFloat(document.getElementById('carrierFrequency').value);
        const samplingFreq = (messageFreq > carrierFreq) ? messageFreq * 10 : carrierFreq * 10;

        // Check if the sampling frequency is less than or equal to either the message or carrier frequency
        if (samplingFreq <= 2*messageFreq || samplingFreq <= 2*carrierFreq) {
            alert("The number of FFT Points must be at least two times higher than both the input frequency 1 and input frequency 2.");
        } 
    }

    // Select all button elements on the page
    const buttons1 = document.querySelectorAll('button');

    // Attach the click event listener to each button
    buttons1.forEach(button => {
        button.addEventListener('click', checkFrequencies2);
    });

*/
</script>

	
    <script>
	/*
        function generateSinusoid(fm, fs, L) {
            let tt = [];
            let y = [];
            for (let i = 0; i < L; i++) {
                let t = i / fs;
                tt.push(t);
                y.push(Math.sin(2 * Math.PI * fm * t));
            }
            return { tt, y };
        }
*/

        function addNoise(signal, snr_db) {
            let snr_linear = Math.pow(10, snr_db / 10);
            let signal_power = signal.reduce((sum, val) => sum + val * val, 0) / signal.length;
            let noise_variance = signal_power / snr_linear;
            return signal.map(val => val + Math.sqrt(noise_variance) * randn());
        }

        function fft(signal) {
            let N = signal.length;
            let X = new Array(N).fill(0).map(() => [0, 0]);

            for (let k = 0; k < N; k++) {
                for (let n = 0; n < N; n++) {
                    let phi = (2 * Math.PI * k * n) / N;
                    let cos = Math.cos(phi);
                    let sin = Math.sin(phi);
                    X[k][0] += signal[n] * cos;  // Real part
                    X[k][1] -= signal[n] * sin;  // Imaginary part
                }
            }
            return X;
        }

        function ifft(X) {
            let N = X.length;
            let x = new Array(N).fill(0);

            for (let n = 0; n < N; n++) {
                for (let k = 0; k < N; k++) {
                    let phi = (2 * Math.PI * k * n) / N;
                    let cos = Math.cos(phi);
                    let sin = Math.sin(phi);
                    x[n] += (X[k][0] * cos - X[k][1] * sin) / N;
                }
            }
            return x;
        }

        function multiplyComplexArrays(A, B) {
            return A.map((a, i) => [
                a[0] * B[i][0] - a[1] * B[i][1],  // Real part
                a[0] * B[i][1] + a[1] * B[i][0]   // Imaginary part
            ]);
        }

        function autoCorrelation(X) {
            return multiplyComplexArrays(X, X.map(x => [x[0], -x[1]]));  // X .* conj(X)
        }

        function crossCorrelation(X, Y) {
            return multiplyComplexArrays(X, Y.map(y => [y[0], -y[1]]));  // X .* conj(Y)
        }

         function toeplitz(column, row) {
            let n = column.length;
            let toeplitzMatrix = [];

            for (let i = 0; i < n; i++) {
                toeplitzMatrix[i] = [];
                for (let j = 0; j < n; j++) {
                    if (j >= i) {
                        toeplitzMatrix[i][j] = row[j - i];
                    } else {
                        toeplitzMatrix[i][j] = column[i - j];
                    }
                }
            }
            return toeplitzMatrix;
        }

        function transpose(matrix) {
         return matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));
         }
		 
function solveToeplitz(toeplitzMatrix, Rxy) {
    let N = toeplitzMatrix.length;

    // Check if the matrix is square
    if (N === 0 || toeplitzMatrix.some(row => row.length !== N)) {
        throw new Error('Toeplitz matrix must be square and non-empty.');
    }

    // Initialize solution vector B with zeros
    let B = new Array(N).fill(0);

    // Perform Gaussian elimination to solve the linear system
    for (let i = 0; i < N; i++) {
        // Check for zero pivot
        if (toeplitzMatrix[i][i] === 0) {
            throw new Error('Matrix is singular and cannot be solved.');
        }

        // Normalize the pivot row
        let pivot = toeplitzMatrix[i][i];
        for (let j = 0; j < N; j++) {
            toeplitzMatrix[i][j] /= pivot; // Normalize row
        }
        Rxy[i] /= pivot; // Normalize Rxy as well

        // Eliminate entries below the pivot
        for (let j = i + 1; j < N; j++) {
            let factor = toeplitzMatrix[j][i];
            for (let k = 0; k < N; k++) {
                toeplitzMatrix[j][k] -= factor * toeplitzMatrix[i][k];
            }
            Rxy[j] -= factor * Rxy[i]; // Update Rxy
        }
    }

    // Back substitution to find the solution
    for (let i = N - 1; i >= 0; i--) {
        B[i] = Rxy[i];
        for (let j = i + 1; j < N; j++) {
            B[i] -= toeplitzMatrix[i][j] * B[j];
        }
    }

    return B;
}
		
		// Function to compute the full convolution of two signals
       function convolve(signal1, signal2) {
    let result = new Array(signal1.length + signal2.length - 1).fill(0);
    for (let i = 0; i < signal1.length; i++) {
        for (let j = 0; j < signal2.length; j++) {
            result[i + j] += signal1[i] * signal2[j];
        }
    }
    return result;
}

  function complex(re, im) {
    return { re: re, im: im };
  }

  function addComplex(a, b) {
    return complex(a.re + b.re, a.im + b.im);
  }

  function subtractComplex(a, b) {
    return complex(a.re - b.re, a.im - b.im);
  }

  function multiplyComplex(a, b) {
    return complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
  }

  function scaleComplex(a, scalar) {
    return complex(a.re * scalar, a.im * scalar);
  }

  function fft(input) {
    const N = input.length;
    if (N <= 1) return input;

    // Split into even and odd elements
    const even = fft(input.filter((_, i) => i % 2 === 0));
    const odd = fft(input.filter((_, i) => i % 2 !== 0));

    const result = Array(N).fill(null).map(() => complex(0, 0));
    for (let k = 0; k < N / 2; k++) {
      const t = multiplyComplex(
        odd[k],
        complex(Math.cos(-2 * Math.PI * k / N), Math.sin(-2 * Math.PI * k / N))
      );
      result[k] = addComplex(even[k], t);
      result[k + N / 2] = subtractComplex(even[k], t);
    }
    return result;
  }

  function ifft(input) {
    const N = input.length;

    // Conjugate the input
    const conjugated = input.map(x => complex(x.re, -x.im));

    // Compute FFT of conjugated input
    const fftResult = fft(conjugated);

    // Conjugate and scale the output, then take only the real part
    return fftResult.map(x => x.re / N);
  }
  
          const rr = {
            showLink: false,             
            displaylogo: false,           
            modeBarButtonsToRemove: ['sendDataToCloud'] 
        };

        let fs;    // Sampling frequency
		let fm;
		let fc;
        let T = 1;        // Total recording time (1 second)
        let L;   // Signal length
        //let { tt, y } = generateSinusoid(120, fs, L);
        let snr_db;
        let x;
		//let y, y2, y3;
		let label, label2;
		inputSignal2 = document.getElementById('inputSignal2');
		plot11 = document.getElementById('plot11');
function handleInputChange(fs, fm, fc) {
    // Get the selected inputs from the dropdowns
    const selectedInput = document.getElementById('inputSelector').value;
    const selectedInput2 = document.getElementById('inputSelector2').value; // Assuming there is a second selector
    const selectedMasterInput = document.getElementById('masterInputSelector').value; // Assuming there is a master input selector

    // Generate time vector
    let tt = Array.from({ length: fs }, (_, i) => i / fs);

    // Initialize output variables
    let y, y2, y3;

    // Perform operations based on the first input selection
    switch (selectedInput) {
        case 'sine':
            y = tt.map((x) => Math.sin(2 * Math.PI * fm * x));
            break;
        case 'cosine':
            y = tt.map((x) => Math.cos(2 * Math.PI * fm * x));
            break;
    case 'rectangular':
        // Define the frequency and duty cycle
        const frequency = parseInt(document.getElementById('messageFrequency').value);  // Frequency of the rectangular signal in Hz
        const dutyCycle = 50; // Duty cycle in percentage (e.g., 50% duty cycle)
        
        const period = 1 / frequency; // Period of the rectangular signal (in seconds)
        const pulseWidth = period * (dutyCycle / 100); // Pulse width calculated from duty cycle

        y = tt.map((x) => {
            // Create a rectangular pulse based on pulseWidth and period
            return (x % period < pulseWidth) ? 1 : 0;
        });
        break;
        default:
            alert('Please select a valid input for the first signal.');
            return null;
    }

    // Perform operations based on the second input selection
    switch (selectedInput2) {
        case 'sine':
            y2 = tt.map((x) => Math.sin(2 * Math.PI * fc * x));
            break;
        case 'cosine':
            y2 = tt.map((x) => Math.cos(2 * Math.PI * fc * x));
            break;
    case 'rectangular':
        // Define the frequency and duty cycle
        const frequency = parseInt(document.getElementById('carrierFrequency').value);  // Frequency of the rectangular signal in Hz
        const dutyCycle = 50; // Duty cycle in percentage (e.g., 50% duty cycle)
        
        const period = 1 / frequency; // Period of the rectangular signal (in seconds)
        const pulseWidth = period * (dutyCycle / 100); // Pulse width calculated from duty cycle

        y2 = tt.map((x) => {
            // Create a rectangular pulse based on pulseWidth and period
            return (x % period < pulseWidth) ? 1 : 0;
        });
        break;
        default:
            alert('Please select a valid input for the second signal.');
            return null;
    }

    // Ensure y and y2 have the same length for addition and subtraction
    if (y.length !== y2.length) {
        alert('The signals must have the same length for the selected operation.');
        return null;
    }

// Perform operations based on the master input selection
switch (selectedMasterInput) {
    case 'addition':
        y3 = y.map((value, index) => value + y2[index]);
    label = document.querySelector('label[for="inputSelector2"]');
    label.style.display = 'block';
	inputSelector2.style.display = 'block';
	label2 = document.querySelector('label[for="carrierFrequency"]');
	label2.style.display = 'block';
	carrierFrequency.style.display = 'block';
	hideButton.style.display = 'block';
	hideButton1.style.display = 'block';
	inputSignal2.style.display = 'block';
	plot11.style.display = 'block';
        break;
    case 'subtraction':
        y3 = y.map((value, index) => value - y2[index]);
    label = document.querySelector('label[for="inputSelector2"]');
    label.style.display = 'block';
	inputSelector2.style.display = 'block';
	label2 = document.querySelector('label[for="carrierFrequency"]');
	label2.style.display = 'block';
	carrierFrequency.style.display = 'block';
	hideButton.style.display = 'block';
	hideButton1.style.display = 'block';
    inputSignal2.style.display = 'block';
	plot11.style.display = 'block';
        break;
    case 'multiplication':
        y3 = y.map((value, index) => value * y2[index]);
	label = document.querySelector('label[for="inputSelector2"]');
    label.style.display = 'block';
	inputSelector2.style.display = 'block';
	label2 = document.querySelector('label[for="carrierFrequency"]');
	label2.style.display = 'block';
	carrierFrequency.style.display = 'block';
	hideButton.style.display = 'block';
	hideButton1.style.display = 'block';
    inputSignal2.style.display = 'block';
	plot11.style.display = 'block';
        break;
    case 'convolution':
    label = document.querySelector('label[for="inputSelector2"]');
    label.style.display = 'block';
	inputSelector2.style.display = 'block';
	label2 = document.querySelector('label[for="carrierFrequency"]');
	label2.style.display = 'block';
	carrierFrequency.style.display = 'block';
	hideButton.style.display = 'block';
	hideButton1.style.display = 'block';
	inputSignal2.style.display = 'block';
	plot11.style.display = 'block';
	y3 = convolve(y, y2); // Ensure the `convolve` function is defined elsewhere in your code
		break;
		
	case 'fourierDifferentiation':
	/*
        const inputData = y;
		  // Helper function to display FFT and IFFT results as arrays
  function computeFFT() {
    // Convert inputData to an array of complex numbers with zero imaginary parts
    const inputArray = inputData.map(x => complex(x, 0));

    // Compute FFT
    const fftResult = fft(inputArray);
    

  }

  function computeIFFT() {
    // Convert inputData to an array of complex numbers with zero imaginary parts
    const inputArray = inputData.map(x => complex(x, 0));

    // Compute FFT first
    const fftResult = fft(inputArray);
	
	///////////////////////////////////////////////
	let L = parseInt(document.getElementById('samplingFrequency').value);  // Sampling frequency
    L = nextPowerOfTwo(L);
	let Fs = parseInt(document.getElementById('samplingFrequency').value);  // Sampling frequency
    Fs = nextPowerOfTwo(Fs);
	    // Frequency vector and shifted frequency
    const freq = Array.from({length: L}, (_, i) => i * Fs / L);
    const freq_shifted = freq.map(f => f >= Fs / 2 ? f - Fs : f);

    // Fourier Differentiation
    const j = { re: 0, im: 1 };
    const k = freq_shifted.map(f => 2 * Math.PI * f);
    const dX = fftResult.map((Xk, i) => ({
        re: -j.im * k[i] * Xk.im,
        im: j.im * k[i] * Xk.re
    }));
    //const dx_dt = ifft(dX).map(val => val.re);
	///////////////////////////////////////////////

    // Compute IFFT of the FFT result and display only the real part
    y3 = ifft(dX);//ifft(fftResult);//const ifftResult = ifft(fftResult);
  }
  computeFFT();
  computeIFFT();
  	*/
	y3 = y;
    label = document.querySelector('label[for="inputSelector2"]');
    label.style.display = 'none';
	inputSelector2.style.display = 'none';
	label2 = document.querySelector('label[for="carrierFrequency"]');
	label2.style.display = 'none';
	carrierFrequency.style.display = 'none';
	hideButton.style.display = 'none';
	hideButton1.style.display = 'none';
	inputSignal2.style.display = 'none';
	plot11.style.display = 'none';

        break;
		
	case 'fourierIntegration':
        const inputData1 = y;
		  // Helper function to display FFT and IFFT results as arrays
  function computeFFT1() {
    // Convert inputData to an array of complex numbers with zero imaginary parts
    const inputArray1 = inputData1.map(x => complex(x, 0));

    // Compute FFT
    const fftResult1 = fft(inputArray1);
    

  }

  function computeIFFT1() {
    // Convert inputData to an array of complex numbers with zero imaginary parts
    const inputArray2 = inputData1.map(x => complex(x, 0));

    // Compute FFT first
    const fftResult2 = fft(inputArray2);
	
	///////////////////////////////////////////////
	let L1 = (messageFreq > carrierFreq) ? messageFreq * 10 : carrierFreq * 10;	  // Sampling frequency
    L1 = nextPowerOfTwo(L1);
	let Fs1 = (messageFreq > carrierFreq) ? messageFreq * 10 : carrierFreq * 10;	  // Sampling frequency
    Fs1 = nextPowerOfTwo(Fs1);
	    // Frequency vector and shifted frequency
    const freq1 = Array.from({length: L1}, (_, i) => i * Fs1 / L1);
    const freq_shifted1 = freq1.map(f1 => f1 >= Fs1 / 2 ? f1 - Fs1 : f1);

    // Fourier Differentiation
    const j1 = { re: 0, im: 1 };
    const k1 = freq_shifted1.map(f1 => 2 * Math.PI * f1);
    const dX1 = fftResult2.map((Xk, i) => i === 0 ? { re: 0, im: 0 } : {
  re: -Xk.im / k1[i],    // Real part: -Xk.im / k[i]
  im: Xk.re / k1[i]      // Imaginary part: Xk.re / k[i]
    });
    //const dx_dt = ifft(dX).map(val => val.re);
	///////////////////////////////////////////////

    // Compute IFFT of the FFT result and display only the real part
    y3 = ifft(dX1);//ifft(fftResult);//const ifftResult = ifft(fftResult);

  }
  computeFFT1();
  computeIFFT1();
    label = document.querySelector('label[for="inputSelector2"]');
    label.style.display = 'none';
	inputSelector2.style.display = 'none';
	label2 = document.querySelector('label[for="carrierFrequency"]');
	label2.style.display = 'none';
	carrierFrequency.style.display = 'none';
	hideButton.style.display = 'none';
	hideButton1.style.display = 'none';
	inputSignal2.style.display = 'none';
	plot11.style.display = 'none';
        break;
    default:
        alert('Please select a valid operation for combining signals.');
        return null;
}

    // Return the results as an object
    return { y, y2, y3 };
}


function inputSignal1() {
    let fm = parseInt(document.getElementById('messageFrequency').value);
    let fc = parseInt(document.getElementById('carrierFrequency').value);
	let fs = parseInt(document.getElementById('samplingFrequency').value);

    let { y, y2, y3 } = handleInputChange(fs, fm, fc);
    if (!y || !y2 || !y3) return;  // Ensure valid signals

    // Plot y2 and y3 on the same plot
    Plotly.newPlot('inputSignal1', [
        { x: Array.from({ length: fs }, (_, i) => i / fs), y: y, mode: 'lines', name: 'Signal 1' }
    ], { title: 'Input Signal' }, rr);

    //document.getElementById('scrolltoinputsignal1').scrollIntoView({ behavior: 'smooth' });
}
		
function generateInputSignal2() {
    let fm = parseInt(document.getElementById('messageFrequency').value);
    let fc = parseInt(document.getElementById('carrierFrequency').value);
	let fs = parseInt(document.getElementById('samplingFrequency').value);

    let { y, y2, y3 } = handleInputChange(fs, fm, fc);
    if (!y || !y2 || !y3) return;  // Ensure valid signals

    // Plot y2 and y3 on the same plot
    Plotly.newPlot('inputSignal2', [
        { x: Array.from({ length: fs }, (_, i) => i / fs), y: y2, mode: 'lines', name: 'Signal 1' }
    ], { title: 'Input Signal 2' }, rr);

    //document.getElementById('scrolltoinputsignal2').scrollIntoView({ behavior: 'smooth' });
}
		
		        function simulation() {
            // Main Wiener Filter Process
            let fs = parseInt(document.getElementById('samplingFrequency').value);  

            let fm = parseInt(document.getElementById('messageFrequency').value);
            let fc = parseInt(document.getElementById('carrierFrequency').value);

    let { y, y2, y3 } = handleInputChange(fs, fm, fc);
    if (!y || !y2 || !y3) return;  // Ensure valid signals
	

            // User input for SNR in dB
            let snr_db = parseFloat(document.getElementById('snrInput').value);

            // Add Gaussian noise to the signal (assumes addNoise function is defined)
            let x = addNoise(y3, snr_db);

            // Plot original message signal
            Plotly.newPlot('plot11', [
                { x: Array.from({ length: fs }, (_, i) => i / fs), y: y3, mode: 'lines', name: 'Original Message Signal' }
            ], { title: 'Combined Signal' }, rr);
				document.getElementById('scrolltomessage').scrollIntoView({ behavior: 'smooth' });
        }

        
	function generateNoisySignal() {
            let fm = parseInt(document.getElementById('messageFrequency').value);
            let fc = parseInt(document.getElementById('carrierFrequency').value);
			let fs = parseInt(document.getElementById('samplingFrequency').value);	
			let tt = Array.from({ length: fs }, (_, i) => i / fs);

    let { y, y2, y3 } = handleInputChange(fs, fm, fc);
    if (!y || !y2 || !y3) return;  // Ensure valid signals

            // User input for SNR in dB
            let snr_db = parseFloat(document.getElementById('snrInput').value);

            // Add Gaussian noise to the signal (assumes addNoise function is defined)
            let x = addNoise(y3, snr_db);

		        Plotly.newPlot('plot12', [
            { x: tt, y: x, mode: 'lines', name: 'Noisy Signal' },
        ], { title: 'Noisy Signal' }, rr);
			//document.getElementById('scrolltonoisy').scrollIntoView({ behavior: 'smooth' });
    }


        // Generate random Gaussian noise
        function randn() {
            let u1 = Math.random();
            let u2 = Math.random();
            return Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
        }



// Manual PSD calculation function with windowing
function manualPSD(signal, fs) {
    let N = signal.length;

    // Apply the window function to the signal
	// Example Usage
const windowType = document.getElementById('windowType').value; // Change this to 'hamming' or 'rectangular' for testing
//const N = 64; // Length of the window
const idx = 10; // Index for which to compute the window value
    let windowedSignal = signal.map((val, idx) => val * computeWindowValue(windowType, idx, N));

    // Compute the FFT of the windowed signal
    let fft_signal = manualFFT(windowedSignal.map(val => ({ re: val, im: 0 })));

    // Compute the PSD
    let positiveFrequencies = fft_signal.slice(0, Math.floor(N / 2) + 1);
    let psd = positiveFrequencies.map(c => (1 / (fs * N)) * (c.re ** 2 + c.im ** 2));

    // Adjust for one-sided spectrum
    for (let i = 1; i < psd.length - 1; i++) {
        psd[i] *= 2;
    }

    // Frequency axis
    let f = Array.from({ length: Math.floor(N / 2) + 1 }, (_, i) => (i * fs) / N);
    return { psd, f };
}

// Function to compute a single value for the selected window at a specific index
function computeWindowValue(windowType, idx, N) {
    switch (windowType) {
        case 'hann':
            return hannWindow(idx, N); // Compute Hann window value
        case 'hamming':
            return hammingWindow(idx, N); // Compute Hamming window value
        case 'rectangular':
            return rectangularWindow(idx, N); // Compute Rectangular window value
        default:
            console.error('Invalid window type'); // Handle invalid window type
            return null; // Return null for invalid input
    }
}

// Hann window function
function hannWindow(idx, N) {
    return 0.5 * (1 - Math.cos((2 * Math.PI * idx) / (N - 1)));
}

// Hamming window function
function hammingWindow(idx, N) {
    return 0.54 - 0.46 * Math.cos((2 * Math.PI * idx) / (N - 1));
}

// Rectangular window function
function rectangularWindow(idx, N) {
    return 1; // Constant value for rectangular window
}


/*
// Example Usage
const windowType = 'hann'; // Change this to 'hamming' or 'rectangular' for testing
const N = 64; // Length of the window
console.log(computeWindow(windowType, N)); // Logs the computed window values for the selected type
*/


        // Manual FFT implementation (Cooley-Tukey algorithm)
        function manualFFT(signal) {
            let N = signal.length;
            if (N <= 1) return signal;

            if ((N & (N - 1)) !== 0) {
            
                let size = 1 << Math.ceil(Math.log2(N));
                signal = signal.concat(Array(size - N).fill({ re: 0, im: 0 }));
            }

            return fftRecursive(signal);
        }

        function fftRecursive(signal) {
            let N = signal.length;
            if (N <= 1) return signal;

            // Divide
            let even = fftRecursive(signal.filter((_, index) => index % 2 === 0));
            let odd = fftRecursive(signal.filter((_, index) => index % 2 !== 0));

            // Combine
            let result = Array(N).fill({ re: 0, im: 0 });
            for (let k = 0; k < N / 2; k++) {
                let expTerm = {
                    re: Math.cos((-2 * Math.PI * k) / N),
                    im: Math.sin((-2 * Math.PI * k) / N)
                };
                let oddK = complexMultiply(expTerm, odd[k]);
                result[k] = complexAdd(even[k], oddK);
                result[k + N / 2] = complexSubtract(even[k], oddK);
            }
            return result;
        }

        // Complex number operations
        function complexAdd(a, b) {
            return { re: a.re + b.re, im: a.im + b.im };
        }

        function complexSubtract(a, b) {
            return { re: a.re - b.re, im: a.im - b.im };
        }

        function complexMultiply(a, b) {
            return {
                re: a.re * b.re - a.im * b.im,
                im: a.re * b.im + a.im * b.re
            };
        }

        // Function to generate PSD for the original signal
        function generatePSD1() {
            let fs = parseInt(document.getElementById('samplingFrequency').value);			 
			fs = nextPowerOfTwo(fs);
			let tt = Array.from({ length: fs }, (_, i) => i / fs);
            let fm = parseInt(document.getElementById('messageFrequency').value);
            let fc = parseInt(document.getElementById('carrierFrequency').value);

    let { y, y2, y3 } = handleInputChange(fs, fm, fc);
    if (!y || !y2 || !y3) return;  // Ensure valid signals

            // Plot PSD for the original signal
            plotPSD(y3, null, fs, 'psdPlot1'); // Pass y as the original signal, null for x
        }

        // Function to generate PSD for the noisy signal
        function generatePSD2ff() {
            let fs = parseInt(document.getElementById('samplingFrequency').value);			
			fs = nextPowerOfTwo(fs);
			let tt = Array.from({ length: fs }, (_, i) => i / fs);
            let fm = parseInt(document.getElementById('messageFrequency').value);
            let fc = parseInt(document.getElementById('carrierFrequency').value);

    let { y, y2, y3 } = handleInputChange(fs, fm, fc);
    if (!y || !y2 || !y3) return;  // Ensure valid signals

            // Get SNR in dB from user input
            let snr_db = parseFloat(document.getElementById('snrInput').value);
            let snr_linear = Math.pow(10, snr_db / 10); // Convert SNR to linear scale

            // Calculate signal power and noise variance
            let signal_power = y3.reduce((sum, value) => sum + Math.pow(value, 2), 0) / fs;
            let noise_variance = signal_power / snr_linear;

            // Generate noisy signal
            let x = y3.map(value => value + Math.sqrt(noise_variance) * randn());

            // Plot PSD for the noisy signal
            plotPSD(y3, x, fs, 'psdPlot2'); // Pass y as the original signal and x as the noisy signal
        }

        // Updated plotPSD function to take a divId parameter
        function plotPSD(y, x, fs, divId) {
    let fm = parseInt(document.getElementById('messageFrequency').value);
    let fc = parseInt(document.getElementById('carrierFrequency').value);

    // Calculate PSD using various methods
    let { psd: psd_y, f: f_y } = manualPSD(y, fs);
    let { psd: psd_x, f: f_x } = manualPSD(x, fs);
    let { psd: psd_xcorrelogram, f: f_xcorrelogram } = manualPSDCorrelogram(x, fs);
    let { psd: psd_xBartlett, f: f_xBartlett } = manualPSDBartlett(x, fs);
    let { psd: psd_xBlackmanTukey, f: f_xBlackmanTukey } = manualPSDBlackmanTukey(x, fs);
    let { psd: psd_xWelch, f: f_xWelch } = manualPSDWelch(x, fs);

    // Normalize PSDs for dB scale
    let maxVal = Math.max(...psd_x);
    let maxValcorrelogram = Math.max(...psd_xcorrelogram);
    let maxValBartlett = Math.max(...psd_xBartlett);
    let maxValBlackmanTukey = Math.max(...psd_xBlackmanTukey);
    let maxValWelch = Math.max(...psd_xWelch);

    // Convert PSDs to dB and normalize
    let tracePSD2 = {
        x: f_x,
        y: psd_x.map(p => 10 * Math.log10(p) - 10 * Math.log10(maxVal)),
        mode: 'lines',
        name: 'Periodogram',
        line: { color: 'red' }
    };

    let tracePSD2Correlogram = {
        x: f_xcorrelogram,
        y: psd_xcorrelogram.map(p => 10 * Math.log10(p) - 10 * Math.log10(maxValcorrelogram)),
        mode: 'lines',
        name: 'Correlogram',
        line: { color: 'blue' }
    };

    let tracePSDBartlett = {
        x: f_xBartlett,
        y: psd_xBartlett.map(p => 10 * Math.log10(p) - 10 * Math.log10(maxValBartlett)),
        mode: 'lines',
        name: 'Bartlett',
        line: { color: 'green' }
    };

    let tracePSDBlackmanTukey = {
        x: f_xBlackmanTukey,
        y: psd_xBlackmanTukey.map(p => 10 * Math.log10(p) - 10 * Math.log10(maxValBlackmanTukey)),
        mode: 'lines',
        name: 'Blackman-Tukey',
        line: { color: 'purple' }
    };

    let tracePSDWelch = {
        x: f_xWelch,
        y: psd_xWelch.map(p => 10 * Math.log10(p) - 10 * Math.log10(maxValWelch)),
        mode: 'lines',
        name: 'Welch',
        line: { color: 'orange' }
    };

    // --- NEW PART: AR Model Coefficients (added minimally) ---
    let inputValue = document.getElementById('inputN').value;
    let N = inputValue
        .split(',')
        .map(val => val.trim())
        .filter(val => val !== '')
        .map(Number);

    let arText = "<strong>Estimated AR Coefficients (N represents the order):</strong><br>";
    let psdTraces = [tracePSD2, tracePSD2Correlogram, tracePSDBartlett, tracePSDBlackmanTukey, tracePSDWelch];
    let Nfft = 1024; // for AR PSD resolution

    N.forEach((n) => {
        const { a, p } = aryule(x, n);
        arText += `N=${n}: [${a.map(v => v.toFixed(4)).join(", ")}]<br>`;
        const H = Array(Nfft).fill(0).map((_, i) => {
            const omega = (2 * Math.PI * i) / Nfft;
            const numerator = Math.sqrt(p);
            let denominator = { re: 0, im: 0 };
            a.forEach((ai, j) => {
                denominator.re += ai * Math.cos(-omega * j);
                denominator.im += ai * Math.sin(-omega * j);
            });
            return numerator / Math.sqrt(denominator.re ** 2 + denominator.im ** 2);
        });
        let psdModel = H.map(h => 20 * Math.log10(h / (2 * Math.PI)));
        psdModel = psdModel.slice(0, (H.length / 2)).map(a => a + (10 * Math.log10(6.2832 / fs)));
            // Normalize the PSD so the maximum value is 0 dB
    let maxPsdValue = Math.max(...psdModel);
    psdModel = psdModel.map(value => value - maxPsdValue);

        psdTraces.push({
            x: Array.from({ length: (H.length / 2) }, (_, i) => i / H.length).map(a => a * fs),
            y: psdModel,
            mode: 'lines',
            name: `AR Method with N=${n}`,
            line: { dash: 'dot' }
        });
    });

    document.getElementById('arCoefficientsBox').innerHTML = arText;
    // --------------------------------------------------------

    // Final Plotly Plot (with all PSD methods + AR model)
    Plotly.newPlot(divId, psdTraces, {
        title: 'Power Spectral Density of Noisy Signal (Various Methods + AR Method)',
        xaxis: {
            title: 'Frequency (Hz)',
            range: [0, ((fs / 10) + fm + 5)]
        },
        yaxis: {
            title: 'Power/Frequency (dB/Hz)'
        },
        legend: { x: 1, xanchor: 'right', y: 1 }
    });
}


   // FFT implementation
    function fft(signal) {
      const N = signal.length;
      if (N <= 1) return signal.map((val) => ({ re: val, im: 0 }));

      const even = fft(signal.filter((_, i) => i % 2 === 0));
      const odd = fft(signal.filter((_, i) => i % 2 !== 0));
      const T = Array(N / 2).fill(0).map((_, k) => {
        const angle = (-2 * Math.PI * k) / N;
        return {
          re: Math.cos(angle) * odd[k].re - Math.sin(angle) * odd[k].im,
          im: Math.cos(angle) * odd[k].im + Math.sin(angle) * odd[k].re,
        };
      });

      return Array(N).fill(0).map((_, k) =>
        k < N / 2
          ? { re: even[k].re + T[k].re, im: even[k].im + T[k].im }
          : { re: even[k - N / 2].re - T[k - N / 2].re, im: even[k - N / 2].im - T[k - N / 2].im }
      );
    }

    // Periodogram implementation
	fm = parseInt(document.getElementById('messageFrequency').value);
    fc = parseInt(document.getElementById('carrierFrequency').value);	
	let Nfft = (fm > fc) ? fm * 10 : fc * 10;
	Nfft = nextPowerOfTwo(Nfft);
    function periodogram(signal) {
      const paddedSignal = Array(Nfft).fill(0).map((_, i) => (i < signal.length ? signal[i] : 0));
      const fftResult = fft(paddedSignal);
      return fftResult.map(({ re, im }) => (re * re + im * im) / signal.length);
    }

    // AR parameter estimation using Yule-Walker equations
    function aryule(x, order) {
      const autoCorr = Array(order + 1).fill(0).map((_, lag) =>
        x.slice(lag).reduce((sum, xi, i) => sum + xi * x[i], 0)
      );
      const R = Array(order).fill(0).map((_, i) =>
        Array(order).fill(0).map((_, j) => autoCorr[Math.abs(i - j)])
      );
      const r = autoCorr.slice(1, order + 1);

      // Solve linear equations for AR coefficients
      const a = solveLinearSystem(R, r).map((v) => -v);
      const p = autoCorr[0] + a.reduce((sum, ai, i) => sum + ai * autoCorr[i + 1], 0);
      return { a: [1, ...a], p };
    }

    // Linear system solver
    function solveLinearSystem(A, b) {
      const n = A.length;
      const x = Array(n).fill(0);
      const LU = A.map((row) => [...row]);
      const y = [...b];

      // LU Decomposition
      for (let k = 0; k < n; k++) {
        for (let i = k + 1; i < n; i++) {
          const factor = LU[i][k] / LU[k][k];
          for (let j = k; j < n; j++) LU[i][j] -= factor * LU[k][j];
          y[i] -= factor * y[k];
        }
      }

      // Back substitution
      for (let i = n - 1; i >= 0; i--) {
        x[i] = y[i];
        for (let j = i + 1; j < n; j++) x[i] -= LU[i][j] * x[j];
        x[i] /= LU[i][i];
      }

      return x;
    }
    function generatePSD2() {
    let fs = parseInt(document.getElementById('samplingFrequency').value);
    fs = nextPowerOfTwo(fs);
    let fm = parseInt(document.getElementById('messageFrequency').value);
    let fc = parseInt(document.getElementById('carrierFrequency').value);
    let tt = Array.from({ length: fs }, (_, i) => i / fs);

    let { y, y2, y3 } = handleInputChange(fs, fm, fc);
    if (!y || !y2 || !y3) return;  // Ensure valid signals

    // Get SNR in dB from user input
    let snr_db = parseFloat(document.getElementById('snrInput').value);
    let snr_linear = Math.pow(10, snr_db / 10); // Convert SNR to linear scale

    // Calculate signal power and noise variance
    let signal_power = y3.reduce((sum, value) => sum + Math.pow(value, 2), 0) / fs;
    let noise_variance = signal_power / snr_linear;

    // Generate noisy signal
    let x = y3.map(value => value + Math.sqrt(noise_variance) * randn());
    let signalLength = fs; //parseInt(document.getElementById('signalLength').value);
    x = x.slice(1, signalLength);

    // Plot PSD for the noisy signal with various methods
    plotPSD(y3, x, fs, 'psdPlot2'); // Pass y as the original signal and x as the noisy signal
}

//////////////////////////////Phase Info///////////////////
        // Function to zero-pad the array to the nearest power of 2
        function padToPowerOf2(arr) {
            const nextPowerOf2 = 2 ** Math.ceil(Math.log2(arr.length));
            while (arr.length < nextPowerOf2) {
                arr.push(0);
            }
            return arr;
        }
		

        // Manual FFT function
        function fft(x) {
            const N = x.length;
            if (N <= 1) return x;

            // Split into even and odd parts
            const even = fft(x.filter((_, i) => i % 2 === 0));
            const odd = fft(x.filter((_, i) => i % 2 !== 0));

            const combined = new Array(N).fill(0).map(() => ({ re: 0, im: 0 }));
            for (let k = 0; k < N / 2; k++) {
                const twiddle = {
                    re: Math.cos(2 * Math.PI * k / N),
                    im: -Math.sin(2 * Math.PI * k / N)
                };

                const product = {
                    re: twiddle.re * odd[k].re - twiddle.im * odd[k].im,
                    im: twiddle.re * odd[k].im + twiddle.im * odd[k].re
                };

                combined[k] = {
                    re: even[k].re + product.re,
                    im: even[k].im + product.im
                };
                combined[k + N / 2] = {
                    re: even[k].re - product.re,
                    im: even[k].im - product.im
                };
            }
            return combined;
        }

        // Magnitude and phase calculation
        function magnitude(complexArray) {
            return complexArray.map(c => Math.sqrt(c.re ** 2 + c.im ** 2));
        }

        function phase(complexArray) {
            return complexArray.map(c => Math.atan2(c.im, c.re));
        }

		function nextPowerOfTwo(n) {
			if (n < 1) return 1; // Handle cases where n is less than 1
			let power = 1;
			while (power < n) {
				power *= 2; // Multiply by 2 until we exceed n
			}
			return power;
		}
	function phasePlot() {	
	            let fm = parseInt(document.getElementById('messageFrequency').value);
            let fc = parseInt(document.getElementById('carrierFrequency').value);
        // Signal parameters
         let fs = parseInt(document.getElementById('samplingFrequency').value);  // Sampling frequency
		      fs = nextPowerOfTwo(fs);
        const t = Array.from({ length: fs }, (_, i) => i / fs);  // Time vector

        // Signal definition
		    let { y, y2, y3 } = handleInputChange(fs, fm, fc);
    if (!y || !y2 || !y3) return;  // Ensure valid signals
        //const x = t.map(ti => Math.cos(2 * Math.PI * 1500 * ti - Math.PI / 4) - Math.sin(2 * Math.PI * 40 * ti));

        // Zero-pad signal to nearest power of 2
        const paddedX = padToPowerOf2(y3).map(val => ({ re: val, im: 0 }));

        // Compute Fourier Transform
        const y_ff = fft(paddedX);


// Get the value of both input selectors
const inputSelector1 = document.getElementById("inputSelector").value;
const inputSelector2 = document.getElementById("inputSelector2").value;

// Declare the variable tol
let tol;
let z;
// Check if either inputSelector1 or inputSelector2 contains 'rectangular'
if (inputSelector1 === 'rectangular' || inputSelector2 === 'rectangular') {
             z = y_ff.slice().map((_, i, arr) => arr[(i + Math.floor(arr.length / 2)) % arr.length]); // fftshift

} else {

    z = y_ff.slice().map((_, i, arr) => arr[(i + Math.floor(arr.length / 2)) % arr.length]); // fftshift
            // Apply tolerance check
		const maxValue = Math.max(...magnitude(z));
	// Code to run if both inputs are not 'rectangular'
    tol = maxValue - 1;  // Assign value if 'rectangular' is selected in either input
	// You can now use 'tol' for further calculations

        z.forEach((c, index) => {
            if (Math.sqrt(c.re ** 2 + c.im ** 2) < tol) {
                z[index] = { re: 0, im: 0 };  // Set the complex number to zero
            }
        });

}


        // Frequency vector
        const ly = y_ff.length;
        const f = Array.from({ length: ly }, (_, i) => (i - ly / 2) / ly * fs);
/*
        // Plot magnitude of the Fourier Transform
        const magnitudeData = {
            x: f,
            y: magnitude(z),
            type: 'scatter',
            mode: 'lines',
            name: 'Magnitude'
        };

        Plotly.newPlot('magnitudePlot', [magnitudeData], {
            title: 'Magnitude of Fourier Transform',
            xaxis: { title: 'Frequency (Hz)' },
            yaxis: { title: '|y|' }
        });
*/
        // Plot phase of the Fourier Transform
        const phaseData = {
            x: f,
            y: phase(z).map(value => value / Math.PI),//phase(z),
            type: 'scatter',
            mode: 'lines',
            name: 'Phase'
        };

        Plotly.newPlot('phasePlot', [phaseData], {
            title: 'Phase Plot',
            xaxis: { title: 'Frequency (Hz)' },
            yaxis: { title: 'Phase (radians)' }
        }, rr);
		    document.getElementById('scrolltophaseplot').scrollIntoView({ behavior: 'smooth' });
}

///////////////////////////////////////////////////////////		

   // Helper function to hide elements
    function hideElements() {
        const elementsToHide = [
            'label[for="inputSelector2"]',
            'label[for="carrierFrequency"]',
            '#inputSelector2',
            '#carrierFrequency',
            '#hideButton',
            '#hideButton1',
            '#inputSignal2',
            '#plot11',
        ];
        elementsToHide.forEach(selector => {
            const element = document.querySelector(selector);
            if (element) element.style.display = 'none';
        });
    }
	hideElements();
	
  
    function inputSignal() {
	inputSignal1();
generateInputSignal2();
generateNoisySignal();

	}

	function simulateff() {

generatePSD2();
	}


  // CSV input change
document.getElementById('csvInput').addEventListener('change', function (event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function (e) {
        const text = e.target.result;
        const rows = text.split(/\r?\n/).filter(line => line.trim() !== '');
        const signal = rows.map(row => parseFloat(row.split(',')[0])).filter(v => !isNaN(v));
        if (signal.length === 0) return alert('Invalid or empty data.');

        // Update global signal
        x_2 = signal;

        generateLTIOutputxx(); // initial plot
    };

    reader.readAsText(file);
});

// Attach listeners once for dynamic updates
document.getElementById("samplingFrequencyxx").addEventListener('input', generateLTIOutputxx);
document.getElementById("inputNxx").addEventListener('input', generateLTIOutputxx);

function generateLTIOutputxx() {
    // Guard if CSV not loaded yet
    if (!x_2 || x_2.length === 0) return;

    let fs = parseInt(document.getElementById("samplingFrequencyxx").value);
    let inputValue = document.getElementById("inputNxx").value;

    let N = inputValue.split(',').map(val => val.trim()).filter(val => val !== '').map(Number);

    let psd = periodogram(x_2);
    const maxPSD = Math.max(...psd);

    // Plot the input signal
    Plotly.newPlot('signal', [{
        x: [...Array(x_2.length).keys()],
        y: x_2,
        type: 'scatter',
        mode: 'lines',
        name: 'Input Signal'
    }], {
        title: 'Input Signal',
        xaxis: { title: 'Sample Index' }
    });

    let psdTraces = [{
        x: Array.from({ length: psd.length / 2 }, (_, i) => (i / psd.length) * fs),
        y: psd.map(p => 10 * Math.log10(p))  // Convert to dB
            .slice(0, psd.length / 2)
            .map(a => a -  maxPSD),  // Add scaling factor
        mode: 'lines',
        name: 'Periodogram',
        showlegend: false,
    }];

    // Simple Periodogram PSD Calculation
    let periodogramResult = manualPSD(x_2, fs);  // Calculate Simple Periodogram
    const maxPeriodogram = Math.max(...periodogramResult.psd);  // Find max value in the periodogram for normalization
    
    
    psdTraces.push({
        x: periodogramResult.f,  // Frequency values from the periodogram result
        y: periodogramResult.psd
            .map(p => 10 * Math.log10(p))        // Convert to dB
            .map(a => a - 10*Math.log10(maxPeriodogram)),       // Normalize to 0 dB
        mode: 'lines',
        name: 'Periodogram',  // Name for Simple Periodogram
    });

    // Bartlett Method PSD Calculation
    let bartlettResult = manualPSDBartlett(x_2, fs);
    const maxBartlett = Math.max(...bartlettResult.psd);
    psdTraces.push({
        x: bartlettResult.f,
        y: bartlettResult.psd.map(p => 10 * Math.log10(p)).map(a => a - 10*Math.log10(maxBartlett)),  // Normalize to 0 dB
        mode: 'lines',
        name: 'Bartlett',
    });

    // Welch Method PSD Calculation
    let welchResult = manualPSDWelch(x_2, fs);
    const maxWelch = Math.max(...welchResult.psd);
    psdTraces.push({
        x: welchResult.f,
        y: welchResult.psd.map(p => 10 * Math.log10(p)).map(a => a - 10*Math.log10(maxWelch)),  // Normalize to 0 dB
        mode: 'lines',
        name: 'Welch',
    });

    // Blackman-Tukey (Correlogram) Method PSD Calculation
    let correlogramResult = manualPSDCorrelogram(x_2, fs);
    const maxCorrelogram = Math.max(...correlogramResult.psd);
    psdTraces.push({
        x: correlogramResult.f,
        y: correlogramResult.psd.map(p => 10 * Math.log10(p)).map(a => a - 10*Math.log10(maxCorrelogram)),  // Normalize to 0 dB
        mode: 'lines',
        name: 'Correlogram',
    });
    
    // Blackman-Tukey Method PSD Calculation
    let blackmanTukeyResult = manualPSDBlackmanTukey(x_2, fs);
    const maxBlackmanTukey = Math.max(...blackmanTukeyResult.psd);
    psdTraces.push({
        x: blackmanTukeyResult.f,
        y: blackmanTukeyResult.psd.map(p => 10 * Math.log10(p)).map(a => a - 10*Math.log10(maxBlackmanTukey)),  // Normalize to 0 dB
        mode: 'lines',
        name: 'Blackman-Tukey',
    });

    // AR Coefficients and PSD Model (if needed)
    let arText = "<strong>Estimated AR Coefficients (N represents the order):</strong><br>";
    N.forEach((n) => {
        const { a, p } = aryule(x_2, n);
        arText += `N=${n}: [${a.map(v => v.toFixed(4)).join(", ")}]<br>`;

        const H = Array(Nfft).fill(0).map((_, i) => {
            const omega = (2 * Math.PI * i) / Nfft;
            const numerator = Math.sqrt(p);
            let denominator = { re: 0, im: 0 };
            a.forEach((ai, j) => {
                denominator.re += ai * Math.cos(-omega * j);
                denominator.im += ai * Math.sin(-omega * j);
            });
            return numerator / Math.sqrt(denominator.re ** 2 + denominator.im ** 2);
        });

        let psdModel = H.map(h => 20 * Math.log10(h / (2 * Math.PI)));
        psdModel = psdModel.slice(0, (H.length / 2)).map(a => a + (10 * Math.log10(6.2832 / fs)));
            // Normalize the PSD so the maximum value is 0 dB
    let maxPsdValue = Math.max(...psdModel);
    psdModel = psdModel.map(value => value - maxPsdValue);
        psdTraces.push({
            x: Array.from({ length: H.length / 2 }, (_, i) => (i / H.length) * fs),
            y: psdModel,
            mode: 'lines',
            name: `AR Method with N=${n}`,
        });
    });

    document.getElementById('arCoefficientsBox1').innerHTML = arText;

    let layout = {
        title: '',
        xaxis: { title: 'Frequency (Hz)' },
        yaxis: { title: 'PSD (dB/Hz)' },
        legend: {
            orientation: 'h',
            x: 0.5,
            xanchor: 'center',
            y: 10,
            yanchor: 'bottom',
            traceorder: 'normal',
            font: { size: 12 },
            bgcolor: 'rgba(255, 255, 255, 0.5)',
            bordercolor: 'black',
            borderwidth: 1
        },
        margin: { b: 100 },  // Increased bottom margin for the legend
    };

    Plotly.newPlot('output', psdTraces, layout);
}


    
function popUpDiv() {
        document.getElementById("inputFieldsBox").classList.add("popup");
        document.getElementById('outputxx').scrollIntoView({ behavior: 'smooth' });

      }
      
function closePopup() {
        document.getElementById("inputFieldsBox").classList.remove("popup");
      }

      function showDiv() {
    document.getElementById("boxes").style.display = "block";
  } 

  function manualPSDWelch(signal, fs) {
    let segmentLength = parseInt(document.getElementById('windowSize').value);
    segmentLength = nextPowerOfTwo(segmentLength); // Ensure power of 2
    let overlap = 0.75; //parseFloat(document.getElementById('overlap').value);
    let N = signal.length;

    let step = Math.floor(segmentLength * (1 - overlap));
    let segments = [];
    for (let start = 0; start + segmentLength <= N; start += step) {
        segments.push(signal.slice(start, start + segmentLength));
    }

    let windowType = document.getElementById('windowType').value;

    let windowValues = Array.from({ length: segmentLength }, (_, n) =>
        computeWindowValue(windowType, n, segmentLength)
    );

    let windowEnergy = windowValues.reduce((sum, w) => sum + w ** 2, 0);
    let psdSum = Array(Math.floor(segmentLength / 2) + 1).fill(0);

    segments.forEach(segment => {
        let windowedSegment = segment.map((val, idx) => val * windowValues[idx]);
        let fftSegment = manualFFT(windowedSegment.map(val => ({ re: val, im: 0 })));

        let segmentPSD = fftSegment.slice(0, Math.floor(segmentLength / 2) + 1)
            .map(c => (1 / (fs * segmentLength * windowEnergy)) * (c.re ** 2 + c.im ** 2));

        psdSum = psdSum.map((val, idx) => val + segmentPSD[idx]);
    });

    psdSum = psdSum.map(val => val / segments.length);

    for (let i = 1; i < psdSum.length - 1; i++) {
        psdSum[i] *= 2;
    }

    let f = Array.from({ length: psdSum.length }, (_, i) => (i * fs) / segmentLength);
    return { psd: psdSum, f };
}

function manualPSDBlackmanTukey(signal, fs) {
    let windowLength = parseInt(document.getElementById('windowSize').value);
	//windowLength = nextPowerOfTwo(windowLength);
    let N = signal.length;

    // Compute the autocorrelation function
    let autocorr = [];
    for (let lag = 0; lag < windowLength; lag++) {
        let sum = 0;
        for (let n = 0; n < N - lag; n++) {
            sum += signal[n] * signal[n + lag];
        }
        autocorr.push(sum / (N - lag));
    }
/*
    // Apply a Blackman window to the autocorrelation
    let blackmanWindow = autocorr.map((_, lag) => {
        return (
            0.42 -
            0.5 * Math.cos((2 * Math.PI * lag) / (windowLength - 1)) +
            0.08 * Math.cos((4 * Math.PI * lag) / (windowLength - 1))
        );
    });
*/	
	let blackmanWindow;
	const windowTypeff = document.getElementById("windowType").value;
if (windowTypeff === 'blackman') {
    // Apply Blackman window
    blackmanWindow = autocorr.map((_, lag) => {
        return (
            0.42 -
            0.5 * Math.cos((2 * Math.PI * lag) / (windowLength - 1)) +
            0.08 * Math.cos((4 * Math.PI * lag) / (windowLength - 1))
        );
    });
}else if (windowTypeff === 'rectangular') {
    // Apply Hamming window
    blackmanWindow = autocorr.map((_, lag) => 1);
}
else if (windowTypeff === 'hann') {
    // Apply Haan window
    blackmanWindow = autocorr.map((_, lag) => {
        return 0.5 * (1 - Math.cos((2 * Math.PI * lag) / (windowLength - 1)));
    });
}
 else if (windowTypeff === 'hamming') {
    // Apply Hamming window
    blackmanWindow = autocorr.map((_, lag) => {
        return 0.54 - 0.46 * Math.cos((2 * Math.PI * lag) / (windowLength - 1));
    });
} else {
    // Default case (e.g., no windowing)
    blackmanWindow = autocorr.map(() => 1);
}


    let taperedAutocorr = autocorr.map((val, idx) => val * blackmanWindow[idx]);

    // Zero-pad the autocorrelation to length N for better frequency resolution

    let paddedAutocorr = [
        ...taperedAutocorr,
        ...Array(N - taperedAutocorr.length).fill(0),
    ];
    /*

    let paddedAutocorr = [
        ...taperedAutocorr,
    ];
    */
    // Perform FFT on the tapered autocorrelation function
    let fft_autocorr = manualFFT(paddedAutocorr.map(val => ({ re: val, im: 0 })));

    // Compute PSD from the FFT of the autocorrelation
    let positiveFrequencies = fft_autocorr.slice(0, Math.floor(N / 2) + 1);
    let psd = positiveFrequencies.map(c => (1 / fs) * (c.re ** 2 + c.im ** 2));

    // Adjust for one-sided spectrum
    for (let i = 1; i < psd.length - 1; i++) {
        psd[i] *= 2;
    }

    // Generate the frequency axis
    let f = Array.from({ length: Math.floor(N / 2) + 1 }, (_, i) => (i * fs) / N);

    return { psd, f };
}


function manualPSDBartlett(signal, fs) {
    let segmentLength = parseInt(document.getElementById('windowSize').value);
    let windowType = document.getElementById('windowType').value;
    let N = signal.length;
    let K = Math.floor(N / segmentLength);
    
    if (K < 1) {
        console.error("Segment length too large or signal too short.");
        return { psd: [], f: [] };
    }

    let psdSum = Array(Math.floor(segmentLength / 2) + 1).fill(0);

    for (let k = 0; k < K; k++) {
        let segment = signal.slice(k * segmentLength, (k + 1) * segmentLength);
        let windowedSegment = segment.map((val, idx) =>
            val * computeWindowValue(windowType, idx, segmentLength)
        );

        let fft_segment = manualFFT(windowedSegment.map(val => ({ re: val, im: 0 })));

        let positiveFrequencies = fft_segment.slice(0, Math.floor(segmentLength / 2) + 1);
        let segmentPSD = positiveFrequencies.map(c =>
            (1 / (fs * segmentLength)) * (c.re ** 2 + c.im ** 2)
        );

        for (let i = 1; i < segmentPSD.length - 1; i++) {
            segmentPSD[i] *= 2;
        }

        psdSum = psdSum.map((val, idx) => val + segmentPSD[idx]);
    }

    let psd = psdSum.map(val => val / K);
    let f = Array.from({ length: Math.floor(segmentLength / 2) + 1 }, (_, i) => (i * fs) / segmentLength);

    return { psd, f };
}

function manualPSDCorrelogram(signal, fs) {
    let N = signal.length;

    // Compute the full autocorrelation function: lags from -(N-1) to (N-1)
    let autocorr = [];
    for (let lag = -(N - 1); lag <= (N - 1); lag++) {
        let sum = 0;
        for (let n = 0; n < N; n++) {
            if (n + lag >= 0 && n + lag < N) {
                sum += signal[n] * signal[n + lag];
            }
        }
        autocorr.push(sum / N);
    }

    // Apply the window function to the autocorrelation
    const windowType = document.getElementById('windowType').value;
    const windowLength = 2 * N - 1;

    let windowedSignal = autocorr.map((val, idx) => val * computeWindowValue(windowType, idx, windowLength));

    // Compute the FFT of the windowed autocorrelation
    let fft_signal = manualFFT(windowedSignal.map(val => ({ re: val, im: 0 })));

    // Compute the PSD from the FFT result
    let positiveFrequencies = fft_signal.slice(0, Math.floor(windowLength / 2) + 1);
    let psd = positiveFrequencies.map(c => (1 / (fs * windowLength)) * (c.re ** 2 + c.im ** 2));

    // Adjust for one-sided spectrum
    for (let i = 1; i < psd.length - 1; i++) {
        psd[i] *= 2;
    }

    // Frequency axis
    let f = Array.from({ length: Math.floor(windowLength / 2) + 1 }, (_, i) => (i * fs) / windowLength);

    return { psd, f };
}
    </script>
	
	<style>
	h1 {
    color: #333;
    font-size: 22px; /* Increased font size */
    margin-bottom: 20px;
}
	ul {
    list-style-type: none;
    fft1: 0;
}

li.step {
  margin: 12px 0;
  padding: 12px 15px;
  border-radius: 6px;
  font-size: 18px;
  font-weight: 500;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
  transition: transform 0.2s ease, background-color 0.2s ease;
}

li.step::before {
  content: "";
  color: #10b981;
  margin-right: 10px;
  font-weight: bold;
}

li.step:hover {
  transform: scale(1.02);
  background-color: #f3f4f6;
}

/* Color code each step */
.step1 {
  background-color: #ffe0e0;
  border-left: 5px solid #ef4444;
}
.step2 {
  background-color: #e0f7ff;
  border-left: 5px solid #0ea5e9;
}
.step3 {
  background-color: #e0ffe5;
  border-left: 5px solid #22c55e;
}
.step4 {
  background-color: #f5e0ff;
  border-left: 5px solid #a855f7;
}
	</style>
  </body>
</html>
